6.1 Cortex-A7 MPCore 简介
Cortex-A7 MPcore 处理器支持 1~4 核,通常是和 Cortex-A15 组成 big.LITTLE 架构的,
Cortex-A15 作为大核负责高性能运算,比如玩游戏啥的, Cortex-A7 负责普通应用,因为 Cortex-
A7 省电。Cortex-A7 本身性能也不弱,不要看它叫做 Cortex-A7 但是它可是比 Cortex-A8 性能
要强大,而且更省电。ARM 官网对于 Cortex-A7 的说明如下:
“在 28nm 工艺下,Cortex-A7 可以运行在 1.2~1.6GHz,并且单核面积不大于 0.45mm 2 (含
有浮点单元、NEON 和 32KB 的 L1 缓存),在典型场景下功耗小于 100mW, 这使得它非常适
合对功耗要求严格的移动设备,这意味着 Cortex-A7 在获得与 Cortex-A9 相似性能的情况下,
其功耗更低”
。
Cortex-A7 MPCore 支持在一个处理器上选配 1~4 个内核, Cortex-A7 MPCore 多核配置如图
6.1.1 所示:
L1 指令
Cache
L1 数据
Cache
处理器0
中断
可选中断
控制器
L1 指令
Cache
L1 数据
Cache
L1 指令
Cache
处理器1
L1 数据
Cache
处理器2
Snoop Control Unit(SCU)
L1 指令
Cache
L1 数据
Cache
处理器3
可选L2
Cache控制器
ACE主接口
图 6.1.1 多核配置图
Cortex-A7 MPCore 的 L1 可选择 8KB、16KB、32KB、64KB,L2 Cache 可以不配,也可以
选择 128KB、256KB、512KB、1024KB。I.MX6UL 配置了 32KB 的 L1 指令 Cache 和 32KB 的
L1 数据 Cache,以及 128KB 的 L2 Cache。Cortex-A7MPCore 使用 ARMv7-A 架构,主要特性如
下:
1、SIMDv2 扩展整形和浮点向量操作。
2、提供了与 ARM VFPv4 体系结构兼容的高性能的单双精度浮点指令,支持全功能的
IEEE754。
3、支持大物理扩展(LPAE),最高可以访问 40 位存储地址,也就是最高可以支持 1TB 的
内存。
4、支持硬件虚拟化。
6、支持 Generic Interrupt Controller(GIC)V2.0。
276I.MX6U 嵌入式 Linux 驱动开发指南
原子哥在线教学:www.yuanzige.com
论坛:www.openedv.com
7、支持 NEON,可以加速多媒体和信号处理算法。
6.2 Cortex-A 处理器运行模型
以前的 ARM 处理器有 7 中运行模型:User、FIQ、IRQ、Supervisor(SVC)、Abort、Undef
和 System,其中 User 是非特权模式,其余 6 中都是特权模式。但新的 Cortex-A 架构加入了
TrustZone 安全扩展,所以就新加了一种运行模式:Monitor,新的处理器架构还支持虚拟化扩
展,因此又加入了另一个运行模式:Hyp,所以 Cortex-A7 处理器有 9 种处理模式,如表 6.2.1
所示:
模式
描述
User(USR) 用户模式,非特权模式,大部分程序运行的时候就处于此模式。
FIQ 快速中断模式,进入 FIQ 中断异常
IRQ 一般中断模式。
Supervisor(SVC) 超级管理员模式,特权模式,供操作系统使用。
Monitor(MON) 监视模式?这个模式用于安全扩展模式。
Abort(ABT) 数据访问终止模式,用于虚拟存储以及存储保护。
Hyp(HYP) 超级监视模式?用于虚拟化扩展。
Undef(UND) 未定义指令终止模式。
System(SYS) 系统模式,用于运行特权级的操作系统任务
注:
‘?’表示为笔者翻译,不保证翻译的准确性。
表 6.2.1 九种运行模式
在表 6.2.1.9 中,除了 User(USR)用户模式以外,其它 8 种运行模式都是特权模式。这几个
运行模式可以通过软件进行任意切换,也可以通过中断或者异常来进行切换。大多数的程序都
运行在用户模式,用户模式下是不能访问系统所有资源的,有些资源是受限的,要想访问这些
受限的资源就必须进行模式切换。但是用户模式是不能直接进行切换的,用户模式下需要借助
异常来完成模式切换,当要切换模式的时候,应用程序可以产生异常,在异常的处理过程中完
成处理器模式切换。
当中断或者异常发生以后,处理器就会进入到相应的异常模式种,每一种模式都有一组寄
存器供异常处理程序使用,这样的目的是为了保证在进入异常模式以后,用户模式下的寄存器
不会被破坏。
如果学过 STM32 和 UCOS、FreeRTOS 就会知道,STM32 只有两种运行模式,特权模式和
非特权模式,但是 Cortex-A 就有 9 种运行模式。
6.3 Cortex-A 寄存器组
本节我们要讲的是 Cortex-A 的内核寄存器组,注意不是芯片的外设寄存器,本节主要参考
《ARM Cortex-A(armV7)编程手册 V4.0.pdf》的“第 3 章 ARM Processor Modes And Registers”。
ARM 架构提供了 16 个 32 位的通用寄存器(R0~R15)供软件使用,前 15 个(R0~R14)可以用
作通用的数据存储,R15 是程序计数器 PC,用来保存将要执行的指令。ARM 还提供了一个当
前程序状态寄存器 CPSR 和一个备份程序状态寄存器 SPSR,SPSR 寄存器就是 CPSR 寄存器的
备份。这 18 个寄存器如图 6.3.1 所示:
277I.MX6U 嵌入式 Linux 驱动开发指南
原子哥在线教学:www.yuanzige.com
堆栈指针
链接寄存器
程序计数器
当前程序状态寄存器
论坛:www.openedv.com
R0
R1
R2
R3
R4
R5
R6
R7
R8
R9
R10
R11
R12
R13 (SP)
R14 (LR)
R15 (PC)
CPSR
SPSR
低寄存器组
高寄存器组
备份程序状态寄存器
有些运行模式下没有
图 6.3.1 Cortex-A 寄存器。
上一小节我们讲了 Cortex-A7 有 9 种运行模式,每一种运行模式都有一组与之对应的寄存
器组。每一种模式可见的寄存器包括 15 个通用寄存器(R0~R14)、一两个程序状态寄存器和一个
程序计数器 PC。在这些寄存器中,有些是所有模式所共用的同一个物理寄存器,有一些是各模
式自己所独立拥有的,各个模式所拥有的寄存器如表 6.3.2 所示:
R0
R1 R0
R1 R0
R1 R0
R1 R0
R1 R0
R1 R0
R1 R0
R1 R2 R2 R2 R2 R2 R2 R2 R2 R0
R1
R2
R3 R3 R3 R3 R3 R3 R3 R3 R3
R4 R4 R4 R4 R4 R4 R4 R4 R4
R5 R5 R5 R5 R5 R5 R5 R5 R5
R6 R6 R6 R6 R6 R6 R6 R6 R6
R7 R7 R7 R7 R7 R7 R7 R7 R7
R8 R8 R8_fiq R8 R8 R8 R8 R8 R8
R9 R9 R9_fiq R9 R9 R9 R9 R9 R9
R10 R10 R10_fiq R10 R10 R10 R10 R10 R10
R11 R11 R11_fiq R11 R11 R11 R11 R11 R11
R12 R12 R12_fiq R12 R12 R12 R12 R12 R12
R13(sp) R13(sp) SP_fiq SP_irq SP_abt SP_svc SP_und SP_mon SP_hyp
R14(lr) R14(lr) LR_fiq LR_irq LR_abt LR_svc LR_und LR_mon R14(lr)
R15(pc) R15(pc) R15(pc) R15(pc) R15(pc) R15(pc) R15(pc) R15(pc) R15(pc)
CPSR CPSR CPSR CPSR CPSR CPSR CPSR CPSR CPSR
SPSR_fiq SPSR_irq SPSR_abt SPSR_svc SPSR_und SPSR_mon SPSR_hyp
ELR_hyp
图 6.3.2 九种模式所对应的寄存器
从图 6.3.2 中浅色字体的是与 User 模式所共有的寄存器,蓝绿色背景的是各个模式所独有
的寄存器。可以看出,在所有的模式中,低寄存器组(R0~R7)是共享同一组物理寄存器的,只是
278I.MX6U 嵌入式 Linux 驱动开发指南
原子哥在线教学:www.yuanzige.com
论坛:www.openedv.com
一些高寄存器组在不同的模式有自己独有的寄存器,比如 FIQ 模式下 R8~R14 是独立的物理寄
存器。假如某个程序在 FIQ 模式下访问 R13 寄存器,那它实际访问的是寄存器 R13_fiq,如果
程序处于 SVC 模式下访问 R13 寄存器,那它实际访问的是寄存器 R13_svc。总结一下,Cortex-
A 内核寄存器组成如下:
1、34 个通用寄存器,包括 R15 程序计数器(PC),这些寄存器都是 32 位的。
2、8 个状态寄存器,包括 CPSR 和 SPSR。
3、Hyp 模式下独有一个 ELR_Hyp 寄存器。
6.3.1 通用寄存器
R0~R15 就是通用寄存器,通用寄存器可以分为以下三类:
1、未备份寄存器,即 R0~R7。
2、备份寄存器,即 R8~R14。
3、程序计数器 PC,即 R15。
分别来看一下这三类寄存器:
1、未备份寄存器
未备份寄存器指的是 R0~R7 这 8 个寄存器,因为在所有的处理器模式下这 8 个寄存器都是
同一个物理寄存器,在不同的模式下,这 8 个寄存器中的数据就会被破坏。所以这 8 个寄存器
并没有被用作特殊用途。
2、备份寄存器
备份寄存器中的 R8~R12 这 5 个寄存器有两种物理寄存器,在快速中断模式下(FIQ)它们对
应着 Rx_irq(x=8~12)物理寄存器,其他模式下对应着 Rx(8~12)物理寄存器。FIQ 是快速中断模
式,看名字就是知道这个中断模式要求快速执行! FIQ 模式下中断处理程序可以使用 R8~R12
寄存器,因为 FIQ 模式下的 R8~R12 是独立的,因此中断处理程序可以不用执行保存和恢复中
断现场的指令,从而加速中断的执行过程。
备份寄存器 R13 一共有 8 个物理寄存器,其中一个是用户模式(User)和系统模式(Sys)共用
的,剩下的 7 个分别对应 7 种不同的模式。R13 也叫做 SP,用来做为栈指针。基本上每种模式
都有一个自己的 R13 物理寄存器,应用程序会初始化 R13,使其指向该模式专用的栈地址,这
就是常说的初始化 SP 指针。
备份寄存器 R14 一共有 7 个物理寄存器,其中一个是用户模式(User)、系统模式(Sys)和超
级监视模式(Hyp)所共有的,
剩下的 6 个分别对应 6 种不同的模式。
R14 也称为连接寄存器(LR),
LR 寄存器在 ARM 中主要用作如下两种用途:
1、每种处理器模式使用 R14(LR)来存放当前子程序的返回地址,如果使用 BL 或者 BLX
来调用子函数的话,R14(LR)被设置成该子函数的返回地址,在子函数中,将 R14(LR)中的值赋
给 R15(PC)即可完成子函数返回,比如在子程序中可以使用如下代码:
MOV PC, LR @寄存器 LR 中的值赋值给 PC,实现跳转
或者可以在子函数的入口出将 LR 入栈:
PUSH {LR} @将 LR 寄存器压栈
在子函数的最后面出栈即可:
POP {PC}
@将上面压栈的 LR 寄存器数据出栈给 PC 寄存器,严格意义上来讲应该是将
@LR-4 赋给 PC,因为 3 级流水线,这里只是演示代码。
2、
当异常发生以后,
该异常模式对应的 R14 寄存器被设置成该异常模式将要返回的地址,
R14 也可以当作普通寄存器使用。
279I.MX6U 嵌入式 Linux 驱动开发指南
原子哥在线教学:www.yuanzige.com
论坛:www.openedv.com
3、程序计数器 R15
程序计数器 R15 也叫做 PC, R15 保存着当前执行的指令地址值加 8 个字节,这是因为 ARM
的流水线机制导致的。ARM 处理器 3 级流水线:取指->译码->执行,这三级流水线循环执行,
比如当前正在执行第一条指令的同时也对第二条指令进行译码,第三条指令也同时被取出存放
在 R15(PC)中。我们喜欢以当前正在执行的指令作为参考点,也就是以第一条指令为参考点,
那么 R15(PC)中存放的就是第三条指令,换句话说就是 R15(PC)总是指向当前正在执行的指令
地址再加上 2 条指令的地址。对于 32 位的 ARM 处理器,每条指令是 4 个字节,所以:
R15 (PC)值 = 当前执行的程序位置 + 8 个字节。
6.3.2 程序状态寄存器
所有的处理器模式都共用一个 CPSR 物理寄存器,因此 CPSR 可以在任何模式下被访问。
CPSR 是当前程序状态寄存器,该寄存器包含了条件标志位、中断禁止位、当前处理器模式标志
等一些状态位以及一些控制位。所有的处理器模式都共用一个 CPSR 必然会导致冲突,为此,
除了 User 和 Sys 这两个模式以外,其他 7 个模式每个都配备了一个专用的物理状态寄存器,叫
做 SPSR(备份程序状态寄存器),当特定的异常中断发生时,SPSR 寄存器用来保存当前程序状
态寄存器(CPSR)的值,当异常退出以后可以用 SPSR 中保存的值来恢复 CPSR。
因为 User 和 Sys 这两个模式不是异常模式,所以并没有配备 SPSR,因此不能在 User 和
Sys 模式下访问 SPSR,会导致不可预知的结果。由于 SPSR 是 CPSR 的备份,因此 SPSR 和
CPSR 的寄存器结构相同,如图 6.3.2.1 所示:
31 30
29 28
N Z C V
27 26
Q
25 24 23
IT[1:0]
J
20 19
Reserved
16 15
GE[3:0]
10 9
IT[7:2]
E
8
7 6 5 4
A I F T
0
M[4:0]
图 6.3.2.1 CPSR 寄存器
N(bit31):当两个补码表示的 有符号整数运算的时候, N=1 表示运算对的结果为负数, N=0
表示结果为正数。
Z(bit30):Z=1 表示运算结果为零,Z=0 表示运算结果不为零,对于 CMP 指令,Z=1 表示
进行比较的两个数大小相等。
C(bit29):在加法指令中,当结果产生了进位,则 C=1,表示无符号数运算发生上溢,其它
情况下 C=0。在减法指令中,当运算中发生借位,则 C=0,表示无符号数运算发生下溢,其它
情况下 C=1。对于包含移位操作的非加/减法运算指令,C 中包含最后一次溢出的位的数值,对
于其它非加/减运算指令,C 位的值通常不受影响。
V(bit28):对于加/减法运算指令,当操作数和运算结果表示为二进制的补码表示的带符号
数时,V=1 表示符号位溢出,通常其他位不影响 V 位。
Q(bit27):仅 ARM v5TE_J 架构支持,表示饱和状态,Q=1 表示累积饱和,Q=0 表示累积
不饱和。
IT[1:0](bit26:25):和 IT[7:2](bit15:bit10)一起组成 IT[7:0],作为 IF-THEN 指令执行状态。
J(bit24):仅 ARM_v5TE-J 架构支持,J=1 表示处于 Jazelle 状态,此位通常和 T(bit5)位一起
表示当前所使用的指令集,如表 6.3.2.1 所示:
J
T
描述
0 0 ARM
0 1 Thumb
1 1 ThumbEE
280I.MX6U 嵌入式 Linux 驱动开发指南
原子哥在线教学:www.yuanzige.com
1
论坛:www.openedv.com
0
Jazelle
表 6.3.2.1 指令类型
GE[3:0](bit19:16):SIMD 指令有效,大于或等于。
IT[7:2](bit15:10):参考 IT[1:0]。
E(bit9):大小端控制位,E=1 表示大端模式,E=0 表示小端模式。
A(bit8):禁止异步中断位,A=1 表示禁止异步中断。
I(bit7):I=1 禁止 IRQ,I=0 使能 IRQ。
F(bit6):F=1 禁止 FIQ,F=0 使能 FIQ。
T(bit5):控制指令执行状态,表明本指令是 ARM 指令还是 Thumb 指令,通常和 J(bit24)一
起表明指令类型,参考 J(bit24)位。
M[4:0]:处理器模式控制位,含义如表 6.3.2.2 所示:
M[4:0]
处理器模式
10000 User 模式
10001 FIQ 模式
10010 IRQ 模式
10011 Supervisor(SVC)模式
10110 Monitor(MON)模式
10111 Abort(ABT)模式
11010 Hyp(HYP)模式
11011 Undef(UND)模式
11111 System(SYS)模式
表 6.3.2.2 处理器模式位
