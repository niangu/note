一、简单工厂模式
主要用于创建对象。新添加类时，不会影响以前的系统代码。核心思想是用一个工厂来根据输入的条件产生不同的类，然后根据不同类的virtual函数得到不同的结果。
适用于不同情况创建不同的类时。
客户端必须要知道基类和工厂类，耦合性差。

二、策略模式
定义算法家族，分别封装起来，让他们之间可以互相切换，让算法变化，不会影响到用户。
适合类中的成员以方法为主，算法经常变动；简化了单元测试（因为每个算法都有自己的类，可以通过自己的接口单独测试）。
策略模式和简单工厂基本相同，但简单工厂模式只能解决对象创建问题，对于经常变动的算法应该使用策率模式。
BUG：客户端要作出判断

二.2、策略与工厂结合
客户端只需访问Context类，而不用知道其它任何类信息，实现了低耦合。

单一职责原则
就一个类而言，应该仅有一个引起它变化的原因。
开放--封闭原则
当变化发生时，我们就创建抽象来隔离以后发生同类的变化。
开放--封闭原则是面向对象的核心所在。开发人员应该对程序中呈现出频繁变化的那部分做出抽象，拒绝对任何部分都刻意抽象及不成熟的抽象。
里氏代换原则
子类型必须能够替换掉他们的父类型。
依赖倒转原则
抽象不应该依赖细节，细节应该依赖抽象，既针对接口编程，不要对实现编程。
高层模块不能依赖底层模块，俩者都应依赖抽象。

三、装饰模式
动态地给一个对象添加一些额外的职责（不重要的功能，只是偶然一次要执行），就增加功能来说，装饰模式比生成子类更为灵活。建造过程不稳定，按正确的顺序串联起来进行控制。
当你向旧的类中添加新代码时,一般是为了添加核心职责或主要行为。而当需
要加入的仅仅是一些特定情况下才会执行的特定的功能时(简单点就是不是核心应用的功
能),就会增加类的复杂度。装饰模式就是把要添加的附加功能分别放在单独的类中,并让
这个类包含它要装饰的对象,当需要执行时,客户端就可以有选择地、按顺序地使用装饰功包装对象。
(四)代理模式
GOOD:远程代理,可以隐藏一个对象在不同地址空间的事实
虚拟代理:通过代理来存放需要很长时间实例化的对象
安全代理:用来控制真实对象的访问权限
智能引用:当调用真实对象时,代理处理另外一些事

(五)工厂方法模式
GOOD:修正了简单工厂模式中不遵守开放-封闭原则。工厂方法模式把选择判
断移到了客户端去实现,如果想添加新功能就不用修改原来的类,直接修改客户端即可。

(六)原型模式
GOOD: 从一个对象再创建另外一个可定制的对象, 而无需知道任何创建的细节。
并能提高创建的性能。 说白了就 COPY 技术,把一个对象完整的 COPY 出一份。

(七)模板方法模式
GOOD: 把不变的代码部分都转移到父类中, 将可变的代码用 virtual 留到子类重写。

迪米特法则
如果两个类不直接通信,那么这两个类就不应当发生直接的相互作用。如果
一个类需要调用另一个类的某个方法的话,可以通过第三个类转发这个调用。

(八)外观模式
GOOD:为子系统的一组接口提供一个一致的界面。使用户使用起来更加方便。
(九)建造者模式(生成器模式)
GOOD: 在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配
方式时适用。 (P115 页)
(十)观察者模式
GOOD:定义了一种一对多的关系,让多个观察对象(公司员工)同时监听一个主题对象(秘书)
,主题对象状态发生变化时,会通知所有的观察者,使它们能够更新自己。

(十一)抽象工厂模式
GOOD:定义了一个创建一系列相关或相互依赖的接口,而无需指定它们的具体
类。
用于交换产品系列,如 ACCESS­>SQL SERVER;
产品的具体类名被具体工厂的实现分离

(十二)状态模式
GOOD:当一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改
变它的行为时,可考虑用到状态模式。

(十三)适配器模式
GOOD:双方都不适合修改的时候,可以考虑使用适配器模式

(十四)备忘录模式
GOOD:在不破坏封装性的前提下,捕获一个对象的内部状态,并在该对象之外
保存这个状态,这样就可以将以后的对象状态恢复到先前保存的状态。
适用于功能比较复杂的,但需要记录或维护属性历史的类;或者需要保存的属性只是众
多属性中的一小部分时 Originator 可以根据保存的 Memo 还原到前一状态。

(十五)组合模式
GOOD:整体和部分可以被一致对待(如 WORD 中复制一个文字、一段文字、
一篇文章都是一样的操作)

(十六)迭代器模式
GOOD:提供一种方法顺序访问一个聚敛对象的各个元素,而又不暴露该对象的
内部表示。
为遍历不同的聚集结构提供如开始,下一个,是否结束,当前一项等统一接口。

(十七)单例模式
GOOD:保证一个类仅有一个实例,并提供一个访问它的全局访问点
(十八)桥接模式
GOOD:将抽象部分与实现部分分离,使它们可以独立变化。
这里说的意思不是让抽象基类与具体类分离,而是现实系统可能有多角度分类,
每一种分类都有可能变化,那么把这种多角度分离出来让它们独立变化,减少它们之间的耦
合性,即如果继承不能实现“开放-封闭原则”的话,就应该考虑用桥接模式。如下例:让
“手机”既可以按品牌分类也可以

(十九)命令模式
GOOD:一、建立命令队列;二、可以将命令记入日志;三、接收请求的一方可
以拒绝;四、添加一个新命令类不影响其它类;
命令模式把请求一个操作的对象与知道怎么操行一个操作的对象分开

(二十)责任链模式
GOOD:使多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的
耦合关系。将这个对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理为止。

(二十一)中介者模式
GOOD:用一个中介对象来封装一系列的对象交互,中介者使各对象不需要显示
的相互引用,从而降低耦合;而且可以独立地改变它们之间的交互。
(二十二)享元模式GOOD:运用共享技术有效地支持大量细粒度的对象(对于 C++来说就是共用一
个内存块啦,对象指针指向同一个地方)
。
如果一个应用程序使用了大量的对象,而这些对象造成了很大的存储开销就应该
考虑使用。
还有就是对象的大多数状态可以外部状态,如果删除对象的外部状态,那么可以
用较少的共享对象取代多组对象,此时可以考虑使用享元。
(二十三)解释器模式
GOOD:通常当一个语言需要解释执行,并且你可以将该语言中的句子表示成为
一个抽象的语法树时,可以使用解释器模式。
(二十四)访问者模式
GOOD:适用于数据结构稳定的系统。它把数据结构和作用于数据结构上的操作
分离开,使得操作集合
优点:新增加操作很容易,因为增加新操作就相当于增加一个访问者,访问者模
式将有关的行为集中到一个访问者对象中












